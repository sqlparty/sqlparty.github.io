---
layout: post
status: publish
published: true
title: MySQL中的事件调度Event Scheduler
author:
  display_name: super
  login: super
  email: sqlparty@gmail.com
  url: ''
author_login: super
author_email: sqlparty@gmail.com
excerpt: "经常需要有一些定时任务在MySQL表上执行，例如统计、迁移、删除无用数据等。之前的作法是利用Linux cron定时运行脚本，但是发现这样的额外依赖有时并不方便，例如单机多实例部署时，就需要分别手动分别配置不同的cron任务，需要额外配置相应的用户和权限；新环境部署时容易遗漏cron任务等。\r\n\r\nMySQL提供了Event
  Scheduler，与Linux下的crontab类似，可以根据时间调度来运行任务，运行一次或多次。\r\n\r\n完整的Event Schduler创建语句如下：\r\n\r\n<span
  style=\"color: #0000ff;\">CREATE<&#47;span>\r\n<span style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp;
  [DEFINER = { user | CURRENT_USER }]<&#47;span>\r\n<span style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp;
  EVENT<&#47;span>\r\n<span style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; [IF NOT EXISTS]<&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; event_name<&#47;span>\r\n<span style=\"color:
  #0000ff;\">&nbsp;&nbsp;&nbsp; ON SCHEDULE <em>schedule<&#47;em><&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; [ON COMPLETION [NOT] PRESERVE]<&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; [ENABLE | DISABLE | DISABLE ON SLAVE]<&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; [COMMENT 'comment']<&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; DO event_body;<&#47;span>\r\n\r\n<span
  style=\"color: #0000ff;\"><em>schedule<&#47;em>:<&#47;span>\r\n<span style=\"color:
  #0000ff;\">&nbsp;&nbsp;&nbsp; AT timestamp [+ INTERVAL <em>interval<&#47;em>] ...<&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp; | EVERY <em>interval<&#47;em><&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; [STARTS timestamp [+ INTERVAL <em>interval<&#47;em>]
  ...]<&#47;span>\r\n<span style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; [ENDS timestamp
  [+ INTERVAL <em>interval<&#47;em>] ...]<&#47;span>\r\n\r\n<span style=\"color: #0000ff;\"><em>interval<&#47;em>:<&#47;span>\r\n<span
  style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp; quantity {YEAR | QUARTER | MONTH |
  DAY | HOUR | MINUTE |<&#47;span>\r\n<span style=\"color: #0000ff;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |<&#47;span>\r\n<span style=\"color:
  #0000ff;\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}<&#47;span>\r\n"
wordpress_id: 795
wordpress_url: http://www.sqlparty.com/?p=795
date: '2013-12-04 22:39:54 +0800'
date_gmt: '2013-12-04 14:39:54 +0800'
categories:
- 数据库
tags:
- MySQL
---
<p>经常需要有一些定时任务在MySQL表上执行，例如统计、迁移、删除无用数据等。之前的作法是利用Linux cron定时运行脚本，但是发现这样的额外依赖有时并不方便，例如单机多实例部署时，就需要分别手动分别配置不同的cron任务，需要额外配置相应的用户和权限；新环境部署时容易遗漏cron任务等。</p>
<p>MySQL提供了Event Scheduler，与Linux下的crontab类似，可以根据时间调度来运行任务，运行一次或多次。</p>
<p>完整的Event Schduler创建语句如下：</p>
<p><span style="color: #0000ff;">CREATE<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [DEFINER = { user | CURRENT_USER }]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; EVENT<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [IF NOT EXISTS]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; event_name<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; ON SCHEDULE <em>schedule<&#47;em><&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ON COMPLETION [NOT] PRESERVE]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ENABLE | DISABLE | DISABLE ON SLAVE]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [COMMENT 'comment']<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; DO event_body;<&#47;span></p>
<p><span style="color: #0000ff;"><em>schedule<&#47;em>:<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; AT timestamp [+ INTERVAL <em>interval<&#47;em>] ...<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp; | EVERY <em>interval<&#47;em><&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [STARTS timestamp [+ INTERVAL <em>interval<&#47;em>] ...]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ENDS timestamp [+ INTERVAL <em>interval<&#47;em>] ...]<&#47;span></p>
<p><span style="color: #0000ff;"><em>interval<&#47;em>:<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; quantity {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}<&#47;span><br />
<!--more--></p>
<h2>一、调度Scheduler<&#47;h2><br />
MySQL中的调度可以是只运行一次，也可以指定时间间隔重复运行。其定义是在event定义的ON SCHEDULE子句中。该子句格式如下：</p>
<p><span style="color: #0000ff;">ON SCHEDULE<&#47;span><br />
<span style="color: #0000ff;">AT timestamp [+ INTERVAL interval] ...<&#47;span><br />
<span style="color: #0000ff;">| EVERY interval<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [STARTS timestamp [+ INTERVAL interval] ...]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ENDS timestamp [+ INTERVAL interval] ...]<&#47;span></p>
<p>其中，timestamp必须包括&rdquo;年月日时分秒&ldquo;，它参与表达式计算后，结果是datetime或者timestamp类型。</p>
<p>而时间间隔interval可以如下：</p>
<p><span style="color: #0000ff;"><数字>&nbsp; {YEAR | QUARTER | MONTH | DAY | HOUR | MINUTE |<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WEEK | SECOND | YEAR_MONTH | DAY_HOUR | DAY_MINUTE |<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DAY_SECOND | HOUR_MINUTE | HOUR_SECOND | MINUTE_SECOND}<&#47;span></p>
<p>其含义很清晰，如YEAR 年；QUARTER 季度；YEAR_MONTH 年+月；MINUTE_SECOND 分钟+秒。</p>
<p>补充：</p>
<ol>
<li>YEAR | QUARTER | MONTH | YEAR_MONTH 后台都转换成MONTH，其他时间间隔都转换成SECOND<&#47;li>
<li>ON SCHEDULE中的时间使用创建时本会话中的时区信息time_zone，这个时区默认是服务端的全局time_zone，也可能后续手动更新掉。这些时间会转化成UTC时间，存储到mysql.event表中。<&#47;li><br />
<&#47;ol></p>
<h3>1.一次运行<&#47;h3><br />
AT直接指定时间，或者使用时间表达式计算得出确定的时间点。</p>
<p>示例：</p>
<ol>
<li><span style="color: #0000ff;">AT '2006-02-10 23:59:00'&nbsp;<&#47;span>&nbsp; 指定确切运行时间，本地时区。<&#47;li>
<li><span style="color: #0000ff;">AT current_timestamp + INTERVAL '1:15' MINUTE_SECOND<&#47;span>&nbsp; 指定1分15秒后运行。<&#47;li><br />
<&#47;ol></p>
<h3>2.多次运行<&#47;h3><br />
EVERY设置运行的时间间隔，这里不能再指定[+ INTERVAL interval]。</p>
<p>指定STARTS、ENDS是可选的。</p>
<ul>
<li>STARTS是指定重复运行的第一次是什么时候。不指定的情况下，会在事件创建时运行第一次，即等价于STARTS CURRENT_TIMESTAMP！<&#47;li>
<li>ENDS告知MySQL结束重复运行的时间点。不指定的情况下，MySQL会永远重复运行下去。<&#47;li><br />
<&#47;ul><br />
示例：</p>
<ol>
<li><span style="color: #0000ff;">EVERY 5 WEEK<&#47;span>&nbsp; 每5周运行一次，创建时运行第一次。<&#47;li>
<li><span style="color: #0000ff;">EVERY 3 DAY STARTS '2013-12-4 09:10:00'&nbsp;<&#47;span> 从'2013-12-4 09:10:00'开始运行第一次，每隔3天运行一次。<&#47;li>
<li><span style="color: #0000ff;">EVERY 2 MONTH STARTS CURRENT_TIMESTAMP + INTERVAL 10 MINUTE ENDS '2014-12-31 23:59:59'<&#47;span> 10分钟后开始到2014年底，每两个月运行一次。<&#47;li><br />
<&#47;ol></p>
<h2>二、事件Event<&#47;h2></p>
<h3>1.启用Event Scheduler功能<&#47;h3><br />
Event是由一个特定的Event Scheduler线程执行的，运行过程中可以通过show full processlist查看其当前状态信息，如：</p>
<p><span style="color: #0000ff;">7384313&nbsp;&nbsp;&nbsp;&nbsp; event_scheduler&nbsp;&nbsp;&nbsp;&nbsp; localhost&nbsp;&nbsp;&nbsp;&nbsp; [NULL]&nbsp;&nbsp;&nbsp;&nbsp; Daemon&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; Waiting on empty queue&nbsp;&nbsp;&nbsp;&nbsp; [NULL]<&#47;span></p>
<p>默认事件调度Event Scheduler功能是未启用的，需要配置全局参数event_scheduler，本参数可以动态设置，即时生效。</p>
<p>event_scheduler有如下三种取值：</p>
<ul>
<li>OFF&#47;0 关闭，默认值。不运行Event Scheduler线程，也就无法进行事件调度。设置为ON可以立即启用。<&#47;li>
<li>ON&#47;1 启用。<&#47;li>
<li>DISABLED 禁用。同样不运行Event Scheduler线程。只有在MySQL服务启动时设置才有用。当event_scheduler是ON或者OFF时，不能在运行时设置event_scheduler为DISABLED。如果启动时配置了event-scheduler=DISABLED，则运行时就不能设置为ON&#47;OFF。换句话中，可以在MySQL服务启动时设置为DISABLED，然后完全禁用了event_scheduler，不能动态调整。<&#47;li><br />
<&#47;ul><br />
所以，要启用event_scheduler，运行时执行：</p>
<p><span style="color: #0000ff;">set global event_scheduler=on<&#47;span></p>
<p>要随MySQL服务一起启用，则在&#47;etc&#47;my.cnf中添加<br />
<span style="color: #0000ff;">[mysqld]<&#47;span><br />
<span style="color: #0000ff;">event-scheduler=on<&#47;span></p>
<h3>2.CREATE EVENT<&#47;h3><br />
创建Event，需要所创建event的数据库下的EVENT权限。</p>
<p>一个event定义至少包括三部分：</p>
<ol>
<li><span style="color: #0000ff;">CREATE EVENT <event_name><&#47;span>。<event_name>在该库中唯一，不区分大小写，最大64个字符。<&#47;li>
<li>一个<span style="color: #0000ff;">ON SCHEDULE<&#47;span>子句。决定了event执行的周期。<&#47;li>
<li>一个<span style="color: #0000ff;">DO<&#47;span>子句。包含了事件的SQL操作集合。<&#47;li><br />
<&#47;ol><br />
其他event子句说明：</p>
<ol>
<li>&nbsp;<span style="color: #0000ff;">[DEFINER = { user | CURRENT_USER }]<&#47;span>&nbsp; 设置运行时进行权限验证的用户，如需指定则应使用'user'@'host'格式，并需要SUPER权限。不指定则为当前用户。<&#47;li>
<li><span style="color: #0000ff;">[ON COMPLETION [NOT] PRESERVE]<&#47;span>&nbsp; 默认为ON COMPLETION NOT PRESERVE，即event在完成后即自动删除。指定ON COMPLETION PRESERVE使得完成后event依然保留。<&#47;li>
<li><span style="color: #0000ff;">[ENABLE | DISABLE | DISABLE ON SLAVE]&nbsp;<&#47;span> 默认为ENABLE，即创建后立即启用。可以设置为DISABLE，创建后不启用，后续使用ALTER event来控制启动、停止。DISABLE ON SLAVE是Replication环境下Slave上的event的状态，表示是Master上创建，复制到SLAVE上的，在SLAVE上无需运行。因为event内的操作会通过binlog同步到slave。<&#47;li>
<li><span style="color: #0000ff;">COMMENT<&#47;span> 注释。<&#47;li><br />
<&#47;ol></p>
<h3>3.Do子句<&#47;h3><br />
在Do子句中实现事件的具体逻辑，几乎所有可以在存储程序中运行的MySQL语句都可以在event中使用。</p>
<p>1）简单SQL示例：<br />
<span style="color: #0000ff;">CREATE EVENT e_hourly<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; ON SCHEDULE<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EVERY 1 HOUR<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; COMMENT 'Clears out sessions table each hour.'<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; DO<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DELETE FROM site_activity.sessions;<&#47;span></p>
<p>2）复杂SQL示例：<br />
<span style="color: #0000ff;">delimiter |<&#47;span><br />
<span style="color: #0000ff;">CREATE EVENT e<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; ON SCHEDULE<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EVERY 5 SECOND<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; DO<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BEGIN<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE v INTEGER;<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECLARE CONTINUE HANDLER FOR SQLEXCEPTION BEGIN END;<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET v = 0;<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHILE v < 5 DO<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INSERT INTO t1 VALUES (0);<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UPDATE t2 SET s1 = s1 + 1;<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SET v = v + 1;<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END WHILE;<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; END |<&#47;span><br />
<span style="color: #0000ff;">delimiter ;<&#47;span></p>
<p>3）Do子句中SQL的限制</p>
<p>基本上Do中可以使用任何在存储程序(Stored Routine)中允许的SQL语句，而存储程序中有些限制，event还有些额外的限制。</p>
<p>Stored Routine中如下语句不允许：</p>
<ol>
<li>LOCK TABLES&#47;UNLOCK TABLES<&#47;li>
<li>LOAD DATA与LOAD TABLE<&#47;li>
<li>支持动态SQL(PREPARE, EXECUTE, DEAALOCATE PREPARE)！但是PREPARE本身有些语句不允许执行。<&#47;li>
<li>INSERT DELAYED不会生效<&#47;li><br />
<&#47;ol><br />
EVENT的限制：</p>
<ol>
<li>如果Do子句中包含ALTER EVENT子句，虽然能够创建，但是运行时会出错。<&#47;li>
<li>不要在Do子句中使用SELECT或SHOW这样仅仅是查询的语句，因为其输出无法从外部获取到。可以使用SELECT ... INTO 这样的形式将查询结果保存起来。<&#47;li><br />
<&#47;ol></p>
<h3>4.ALTER EVENT<&#47;h3><br />
语法：</p>
<p><span style="color: #0000ff;">ALTER<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [DEFINER = { user | CURRENT_USER }]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; EVENT event_name<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ON SCHEDULE schedule]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ON COMPLETION [NOT] PRESERVE]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [RENAME TO new_event_name]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [ENABLE | DISABLE | DISABLE ON SLAVE]<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [COMMENT 'comment']<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp; [DO event_body]<&#47;span></p>
<p>可以看到基本支持CREATE EVENT所涉及的所有子句更新，还支持改名RENAME TO。具有event权限即可。</p>
<p>RENAME TO支持移动EVENT到另一个数据库，如：</p>
<p><span style="color: #0000ff;">ALTER EVENT olddb.myevent<&#47;span><br />
<span style="color: #0000ff;">&nbsp;&nbsp;&nbsp;&nbsp; RENAME TO newdb.myevent;<&#47;span></p>
<p>此时要求有连个数据库上的event。</p>
<p>常用的还有：</p>
<p>启用、停用EVENT&mdash;&mdash;ALTER EVENT myevent DISABLE&#47;ENABLE，我们知道DISABLE ON SLAVE是Replication环境中SLAVE中event的状态，默认是自动设置的。有时需要手动设置。</p>
<h3>5.查看EVENT<&#47;h3><br />
有如下方式可以查看event的信息：</p>
<ul>
<li>mysql.event<&#47;li>
<li>information_schema.events<&#47;li>
<li>show events<&#47;li>
<li>show create event<&#47;li><br />
<&#47;ul></p>
<h3>6.删除EVENT<&#47;h3><br />
任何具有该数据库下的event权限的用户都可以删除event，不管是否是他拥有的event。</p>
<p>删除命令：<span style="color: #0000ff;">DROP EVENT [IF EXISTS] <event name><&#47;span>。</p>
<h2>三、event schedule其他注意点<&#47;h2></p>
<ol>
<li>MySQL保存了事件创建时的sql_mode作为其运行时的sql_mode;<&#47;li>
<li>如果在一个调度区间内任务没有处理完成，新的调度依然会生成，这样就会出现同时又多个任务在运行的情况。如果要避免多个任务同时存在，可以使用GET_LOCK()函数或者行锁、表锁。<&#47;li><br />
<&#47;ol><br />
更多关于时区影响、event使用注意点，请参考文档：<br />
<a href="http:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.5&#47;en&#47;events.html" target="_blank">http:&#47;&#47;dev.mysql.com&#47;doc&#47;refman&#47;5.5&#47;en&#47;events.html<&#47;a></p>
